1. Из интернета с одного из ресурсов скачал скрипт создания учебной БД и наполнения ее данными.
   Структура одной из таблиц, которую буду секционировать:

   CREATE TABLE superheroes(
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100),
    align VARCHAR(30),
    eye VARCHAR(30),
    hair VARCHAR(30),
    gender VARCHAR(30),
    appearances INT,
    year INT,
    universe VARCHAR(10)
);

4. Ищем варианты партицирования. Видятся следующие варианты:

- по полю gender:

select distinct gender from superheroes;

gender                |
----------------------+
Genderfluid Characters|
Male Characters       |
Agender Characters    |
Female Characters     |
Genderless Characters |

- по полю year (по векам):

select distinct round(year/100, 0) from superheroes;

round|
-----+
   19|
   20|

- По полю name. Запрос ниже выдает пустоту, т.е., значение поля в рамках таблицы уникально:

select a.name from superheroes a group by a.name having count(*) = 1

Для решения задания буду использовать декларативный метод. Он начал развиваться с 10 версии постгреса, до того был доступен лишь метод наследования, когда неообходимо было создавать тригер на родительскую таблицу, который уже управлял записями дочерних таблиц (партиций).

5. Экспериментируем с секционированием по списку значений по полю gender:

CREATE TABLE superheroes_1(
    id INT,
    name VARCHAR(100),
    align VARCHAR(30),
    eye VARCHAR(30),
    hair VARCHAR(30),
    gender VARCHAR(30),
    appearances INT,
    year INT,
    universe VARCHAR(10)
) partition by list (gender);


create table superheroes_1_gender_1 partition of superheroes_1 for values in ('Male Characters');
create table superheroes_1_gender_2 partition of superheroes_1 for values in ('Genderless Characters');
create table superheroes_1_gender_3 partition of superheroes_1 for values in ('Female Characters');
create table superheroes_1_gender_4 partition of superheroes_1 for values in ('Genderfluid Characters');
create table superheroes_1_gender_5 partition of superheroes_1 for values in ('Agender Characters');

6. Добавляем данные из основной таблицы:
insert into superheroes_1
select * from superheroes;

7. Получаем распределение количества строк по секциям:
SELECT tableoid::regclass, count(*) FROM superheroes_1 GROUP BY tableoid order by 1;

tableoid              |count|
----------------------+-----+
superheroes_1_gender_1| 4879|
superheroes_1_gender_2|    3|
superheroes_1_gender_3| 2373|
superheroes_1_gender_4|    2|
superheroes_1_gender_5|   24|

Т.е., имело бы смысл для данной задачи создать 3 секции вместо 5, куда "отправлять" все экзотические записи, в отличии от 2-х основных.

8. Экспериментируем с секционированием по диапазону - поле year:

CREATE TABLE superheroes_2(
    id INT,
    name VARCHAR(100),
    align VARCHAR(30),
    eye VARCHAR(30),
    hair VARCHAR(30),
    gender VARCHAR(30),
    appearances INT,
    year INT,
    universe VARCHAR(10)
) partition by range (year);

create table superheroes_2_year_1 partition of superheroes_2 for values from (1000) to (2000);
create table superheroes_2_year_2 partition of superheroes_2 for values from (2000) to (3000);

9. Добавляем данные из основной таблицы:
insert into superheroes_2
select * from superheroes;

10. Получаем распределение количества строк по секциям:
SELECT tableoid::regclass, count(*) FROM superheroes_2 GROUP BY tableoid order by 1;

tableoid            |count|
--------------------+-----+
superheroes_2_year_1| 4807|
superheroes_2_year_2| 2474|

11. Экспериментируем с секционированием по хэшу:

CREATE TABLE superheroes_3(
    id INT,
    name VARCHAR(100),
    align VARCHAR(30),
    eye VARCHAR(30),
    hair VARCHAR(30),
    gender VARCHAR(30),
    appearances INT,
    year INT,
    universe VARCHAR(10)
) partition by hash(name);

create table superheroes_hash_1 partition of superheroes_3 FOR VALUES WITH (MODULUS 5, REMAINDER 0);
create table superheroes_hash_2 partition of superheroes_3 FOR VALUES WITH (MODULUS 5, REMAINDER 1);
create table superheroes_hash_3 partition of superheroes_3 FOR VALUES WITH (MODULUS 5, REMAINDER 2);
create table superheroes_hash_4 partition of superheroes_3 FOR VALUES WITH (MODULUS 5, REMAINDER 3);
create table superheroes_hash_5 partition of superheroes_3 FOR VALUES WITH (MODULUS 5, REMAINDER 4);

12. Добавляем данные из основной таблицы:
insert into superheroes_3
select * from superheroes;

13. Получаем распределение количества строк по секциям:

SELECT tableoid::regclass, count(*) FROM superheroes_3 GROUP BY tableoid order by 1;

tableoid          |count|
------------------+-----+
superheroes_hash_1| 1424|
superheroes_hash_2| 1467|
superheroes_hash_3| 1423|
superheroes_hash_4| 1486|
superheroes_hash_5| 1481|

Получилось самое равномерное распределение в отличии от 2-х вышеописанных вариантов, но недостаток его в том, что добавить новые партиции при данном методе секционирования нельзя.